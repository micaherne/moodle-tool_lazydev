<?php

namespace tool_lazydev\local\generator;

require_once($CFG->libdir . '/ddllib.php');

use core\persistent;

class xmldb_generator extends \tool_lazydev\local\generator\generator {

    public function generate_xmldb_table(string $entityname) : \xmldb_table {
        // TODO: Should we only allow generation where entity is marked persistent?

        $result = new \xmldb_table($entityname);
        $result->setComment('Generated by lazydev');

        /**
         * @var \xmldb_field[]
         */
        $fields = []; // Captured for reordering.

        $entitydef = $this->model_reader->get_model()->get_entity_metadata($entityname);

        $defaultfields = persistent::properties_definition();

        foreach ($entitydef['fields'] as $fieldname => $fielddef) {
            if (array_key_exists($fieldname, $defaultfields)) {
                continue;
            }
            $fields[$fieldname] = $this->get_xmldb_field($fieldname, $fielddef);
        }

        // Default fields are already xmldb-friendly.
        foreach ($defaultfields as $fieldname => $fielddef)  {
            $precision = 10;
            if ($fielddef['type'] !== 'int') {
                throw new \coding_exception("Unknown field type {$fielddef['type']}.");
            }
            $fields[$fieldname] = $this->get_xmldb_field($fieldname, $fielddef);
        }

        // Put id first as is convention.
        if (array_key_exists('id', $fields)) {
            $fields = ['id' => $fields['id']] + $fields;
        }

        foreach ($fields as $field) {
            $result->addField($field);
        }

        return $result;
    }

    public function generate_xmldb_structure(string $component) : \xmldb_structure {
        $entities = $this->model_reader->get_model()->get_persistent_entities();
        $result = new \xmldb_structure($component);
        foreach ($entities as $name => $def) {
            $result->addTable($this->generate_xmldb_table($name));
        }
        return $result;
    }

    /**
     * Get an xmldb_field given an entity definition from the model.
     *
     * @param string $fieldname
     * @param array $fielddef entity definition from the model
     * @return \xmldb_field
     */
    protected function get_xmldb_field(string $fieldname, array $fielddef) : \xmldb_field {

        $params = [
            'name' => $fieldname,
            'type' => XMLDB_TYPE_CHAR,
            'precision' => null,
            'unsigned' => null,
            'notnull' => null,
            'sequence' => $fieldname == 'id',
            'default' => null
        ];

        $result = new \xmldb_field($params['name'], $params['type'], $params['precision'], $params['unsigned'],
            $params['notnull'], $params['sequence'], $params['default']);

        foreach ($fielddef as $feature => $value) {
            // If there is no explicit database type, infer it from the Moodle type if possible.
            if ($feature == 'moodle_type' && empty($fielddef['type'])) {
                if (strpos($value, 'PARAM_') !== 0 || !defined($value)) {
                    throw new \coding_exception("Invalid Moodle type $value");
                }
                $paramconstant = constant($value);
                $details = $this->infer_column_details_for_moodle_type($paramconstant);
                $result->setType($details['type']);
                $result->setLength($details['precision']);
            } else if ($feature == 'type') {
                $result->setType($result->getXMLDBFieldType($value));
            } else if ($feature == 'null') {
                $result->setNotNull(!$value ? 'TRUE' : 'FALSE');
            } else if ($feature == 'default') {
                $result->setDefault($value);
            }

            // Work out the default length / precision.
            if (empty($result->getLength())) {
                switch ($result->getType()) {
                    case XMLDB_TYPE_INTEGER:
                        $result->setLength(10);
                }
            }
        }

        return $result;
    }

    public function infer_column_details_for_moodle_type(string $paramconstant) : array {
        $result = [];
        switch ($paramconstant) {
            case PARAM_INT:
            case PARAM_INTEGER:
                $result['type'] = XMLDB_TYPE_INTEGER;
                $result['precision'] = 10;
                break;
            case PARAM_FLOAT:
            case PARAM_NUMBER:
                $result['type'] = XMLDB_TYPE_NUMBER;
                $result['precision'] = 10;
            default:
                $result['type'] = XMLDB_TYPE_CHAR;
                $result['precision'] = 255;
        }
        return $result;
    }

}